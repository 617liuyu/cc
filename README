                           
                           语言的数据类型
   
    C语言有五种基本数据类型：字符、整型、单精度实型、双精度实型和空类型
    C语言还提供了几种聚合类型（aggregate types），包括数组、指针、结构、共用体（联合）、位域和枚举。
    除v o i d类型外，基本类型的前面可以有各种修饰符。修饰符用来改变基本类型的意义，以便更准确地适应各种情况的需求。修饰符如下：
   • signed（有符号）。
   • unsigned（无符号）。
   • long（长型符）。
   • short（短型符）。修饰符s i g n e d、s h o r t、l o n g和u n s i g n e d适用于字符和整数两种基本类型，而l o n g还可用于d o u b l e
（注意，由于long float与d o u b l e意思相同，所以A N S I标准删除了多余的long float）。
    因为整数的缺省定义是有符号数，所以s i n g e d这一用法是多余的，但仍允许使用。某些实现允许将u n s i g n e d用于浮点型，
如unsigned double。但这一用法降低了程序的可移植性，故建议一般不要采用。为了使用方便，C编译程序允许使用整型的简写形式：

• short int 简写为s h o r t。
• long int 简写为l o n g。
• unsigned short int 简写为unsigned short。
• unsigned int 简写为u n s i g n e d。
• unsigned long int 简写为unsigned long。
即，i n t可缺省。

   八进制数（0～7）之间，起始0是必须的引导符。十六进制数（从0～9的数字，并从“a”～“ “f”的字母）。引导符0是必须有的，X即字母可用大写或小写。
     实型常量
     实型常量又称浮点常量，是一个十进制表示的符号实数。
     实型常量的整数部分为0时可以省略，
     字母E或e之前必须有数字，且E或e后面指数必须为整数，

     字符常量
     字符常量是指用一对单引号括起来的一个字符。如‘a’,‘9’,‘!’。
     字符是按其所对应的ASCII码值来存储的，单引号中的字符不能是单引号（’）和反斜杠（\），
     由于C语言中字符常量是按整数（short型）存储的，所以字符常量可以像整数一样在程序中参与相关的运算。例如：
     'a'－32;/*执行结果97-32=65*/
     'A'+32；/*执行结果65+32=97*/
     '9'－9；/*执行结果57-9=48*/

     字符串
     字符串常量是指用一对双引号括起来的一串字符。双引号只起定界作用，双引号括起的字符串中不能是双引号（"）和反斜杠（\），
     C语言中，字符串常量在内存中存储时，系统自动在字符串的末尾加一个“串结束标志”，即ASCII码值为0的字符NULL，常用\0表示。因此在程序中，长度为n个字符的字符串常量，在内存中占有n+1个字节的存储空间。例如，字符串China有5个字符，作为字符串常量"China"存储于内存中时，共占6个字节，系统自动在后面加上NULL字符。
      要特别注意字符串与字符串常量的区别，除了表示形式不同外，其存储性质也不相同，字符'A'只占1个字节，而字符串常量"A"占2个字节。
      字符变量用来存放字符常量，注意只能存放一个字符，不要以为在一个字符变量中可以放字符串。字符变量的定义形式如下：
charc1,c2;
      它表示c1和c2为字符变量，各放一个字符。因此可以用下面语句对c1、c2赋值：
c1='a';c2='b';

                           递归调用

     语言函数可以自我调用。如果函数内部一个语句调用了函数自己，则称这个函数是
“递归”。递归是以自身定义的过程。也可称为“循环定义”。
     递归的例子很多。例如定义整数的递归方法是用数字1，2，3，4，5，6，7，8，9加
上或减去一个整数。例如，数字15是7+8；数字21是9+12；数字12是9+3。
     一种可递归的计算机语言，它的函数能够自己调用自己。一个简单的例子就是计算 
整数阶乘的函数factor()数N的阶乘是1到N之间所有数字的
乘积.例如3的阶乘是1×2×3，即是６。
    factor()和其等效函数fact()如例4-10所示。
-----------------------------------------------------
    facter(n)
    int n;
    { 
        int answer;
        if(n==1)
        return 1;
        answer=f(n-1)*n;
        return answer;
       
    }

------------------------------------------------------
   fact(n)
   int n;
   {   
       int answer=1;
       int i=0;
       for("i=0;i<=n;i++")
       answer=answer*i;
       return answer;

   }
------------------------------------------------------


    非递归函数fact()的执行应该是易于理解的。它应用一个从1开始到指定数值结束的循环。
    在循环中，用“变化”的乘积依次去乘每个数。
    factor()的递归执行比fact()稍复杂。当用参数1调用factor()时，函数返回1；除此之外的其它值调用将返回factor(n-1)*n这个乘积。
为了求出这个表达式的值，用（n-1）调用factor()一直到n等于1，调用开始返回。
    计算2的阶乘时对factor()的首次调用引起了以参数1对factor()的第二次调用。这次调用返回1，然后被2乘（n的初始值），答案 
是2（把printf()语句插入到factor()中，察看各级调用及其中间答案，是很有趣的）。
    当函数调用自己时，在栈中为新的局部变量和参数分配内存，函数的代码用这些变量和参数重新运行。递归调用并不是把函数代码
重新复制一遍，仅仅参数是新的。当每次递归调用返回时，老的局部变量和参数就从栈中消除，从函数内此次函数调用点重新启动运行。
可递归的函数被说成是对自身的“推入和拉出”。
    大部分递归例程没有明显地减少代码规模和节省内存空间。另外，大部分例程的递归形式比非递归形式运行速度要慢一些。这是因为
附加的函数调用增加了时间开销（在许多情况下，速度的差别不太明显）。对函数的多次递归调用可能造成堆栈的溢出。不过溢出的可能
性不大，因为函数的参数和局部变量是存放在堆栈中的。每次新的调用就会产生一些变量的复制品。这个堆栈冲掉其它数据和程序的存储
区域的可能性是存在的。但是除非递归程序运行失控，否则不必为上述情况担心。
    递归函数的主要优点是可以把算法写的比使用非递归函数时更清晰更简洁，而且某些问题，特别是与人工智能有关的问题，更适宜用
递归方法。递归的另一个优点是，递归函数不会受到怀疑，较非递归函数而言，某些人更相信递归函数。编写递归函数时，必须在函数的
某些地方使用if语句，强迫函数在未执行递归调用前返回。如果不这样做，在调用函数后，它永远不会返回。在递归函数中不使用if语句，
是一个很常见的错误。在开发过程中广泛使用printf()和 getchar()可以看到执行过程，并且可以在发现错误后停止运行。

