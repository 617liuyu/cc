                           
                           语言的数据类型
   
    C语言有五种基本数据类型：字符、整型、单精度实型、双精度实型和空类型
    C语言还提供了几种聚合类型（aggregate types），包括数组、指针、结构、共用体（联合）、位域和枚举。
    除v o i d类型外，基本类型的前面可以有各种修饰符。修饰符用来改变基本类型的意义，以便更准确地适应各种情况的需求。修饰符如下：
   • signed（有符号）。
   • unsigned（无符号）。
   • long（长型符）。
   • short（短型符）。修饰符s i g n e d、s h o r t、l o n g和u n s i g n e d适用于字符和整数两种基本类型，而l o n g还可用于d o u b l e
（注意，由于long float与d o u b l e意思相同，所以A N S I标准删除了多余的long float）。
    因为整数的缺省定义是有符号数，所以s i n g e d这一用法是多余的，但仍允许使用。某些实现允许将u n s i g n e d用于浮点型，
如unsigned double。但这一用法降低了程序的可移植性，故建议一般不要采用。为了使用方便，C编译程序允许使用整型的简写形式：

• short int 简写为s h o r t。
• long int 简写为l o n g。
• unsigned short int 简写为unsigned short。
• unsigned int 简写为u n s i g n e d。
• unsigned long int 简写为unsigned long。
即，i n t可缺省。

   八进制数（0～7）之间，起始0是必须的引导符。十六进制数（从0～9的数字，并从“a”～“ “f”的字母）。引导符0是必须有的，X即字母可用大写或小写。
     实型常量
     实型常量又称浮点常量，是一个十进制表示的符号实数。
     实型常量的整数部分为0时可以省略，
     字母E或e之前必须有数字，且E或e后面指数必须为整数，

     字符常量
     字符常量是指用一对单引号括起来的一个字符。如‘a’,‘9’,‘!’。
     字符是按其所对应的ASCII码值来存储的，单引号中的字符不能是单引号（’）和反斜杠（\），
     由于C语言中字符常量是按整数（short型）存储的，所以字符常量可以像整数一样在程序中参与相关的运算。例如：
     'a'－32;/*执行结果97-32=65*/
     'A'+32；/*执行结果65+32=97*/
     '9'－9；/*执行结果57-9=48*/

     字符串
     字符串常量是指用一对双引号括起来的一串字符。双引号只起定界作用，双引号括起的字符串中不能是双引号（"）和反斜杠（\），
     C语言中，字符串常量在内存中存储时，系统自动在字符串的末尾加一个“串结束标志”，即ASCII码值为0的字符NULL，常用\0表示。因此在程序中，长度为n个字符的字符串常量，在内存中占有n+1个字节的存储空间。例如，字符串China有5个字符，作为字符串常量"China"存储于内存中时，共占6个字节，系统自动在后面加上NULL字符。
      要特别注意字符串与字符串常量的区别，除了表示形式不同外，其存储性质也不相同，字符'A'只占1个字节，而字符串常量"A"占2个字节。
      字符变量用来存放字符常量，注意只能存放一个字符，不要以为在一个字符变量中可以放字符串。字符变量的定义形式如下：
charc1,c2;
      它表示c1和c2为字符变量，各放一个字符。因此可以用下面语句对c1、c2赋值：
c1='a';c2='b';

                           递归调用

     语言函数可以自我调用。如果函数内部一个语句调用了函数自己，则称这个函数是
“递归”。递归是以自身定义的过程。也可称为“循环定义”。
     递归的例子很多。例如定义整数的递归方法是用数字1，2，3，4，5，6，7，8，9加
上或减去一个整数。例如，数字15是7+8；数字21是9+12；数字12是9+3。
     一种可递归的计算机语言，它的函数能够自己调用自己。一个简单的例子就是计算 
整数阶乘的函数factor()数N的阶乘是1到N之间所有数字的
乘积.例如3的阶乘是1×2×3，即是６。
    factor()和其等效函数fact()如例4-10所示。
-----------------------------------------------------
    facter(n)
    int n;
    { 
        int answer;
        if(n==1)
        return 1;
        answer=f(n-1)*n;
        return answer;
       
    }

------------------------------------------------------
   fact(n)
   int n;
   {   
       int answer=1;
       int i=0;
       for("i=0;i<=n;i++")
       answer=answer*i;
       return answer;

   }
------------------------------------------------------


    非递归函数fact()的执行应该是易于理解的。它应用一个从1开始到指定数值结束的循环。
    在循环中，用“变化”的乘积依次去乘每个数。
    factor()的递归执行比fact()稍复杂。当用参数1调用factor()时，函数返回1；除此之外的其它值调用将返回factor(n-1)*n这个乘积。
为了求出这个表达式的值，用（n-1）调用factor()一直到n等于1，调用开始返回。
    计算2的阶乘时对factor()的首次调用引起了以参数1对factor()的第二次调用。这次调用返回1，然后被2乘（n的初始值），答案 
是2（把printf()语句插入到factor()中，察看各级调用及其中间答案，是很有趣的）。
    当函数调用自己时，在栈中为新的局部变量和参数分配内存，函数的代码用这些变量和参数重新运行。递归调用并不是把函数代码
重新复制一遍，仅仅参数是新的。当每次递归调用返回时，老的局部变量和参数就从栈中消除，从函数内此次函数调用点重新启动运行。
可递归的函数被说成是对自身的“推入和拉出”。
    大部分递归例程没有明显地减少代码规模和节省内存空间。另外，大部分例程的递归形式比非递归形式运行速度要慢一些。这是因为
附加的函数调用增加了时间开销（在许多情况下，速度的差别不太明显）。对函数的多次递归调用可能造成堆栈的溢出。不过溢出的可能
性不大，因为函数的参数和局部变量是存放在堆栈中的。每次新的调用就会产生一些变量的复制品。这个堆栈冲掉其它数据和程序的存储
区域的可能性是存在的。但是除非递归程序运行失控，否则不必为上述情况担心。
    递归函数的主要优点是可以把算法写的比使用非递归函数时更清晰更简洁，而且某些问题，特别是与人工智能有关的问题，更适宜用
递归方法。递归的另一个优点是，递归函数不会受到怀疑，较非递归函数而言，某些人更相信递归函数。编写递归函数时，必须在函数的
某些地方使用if语句，强迫函数在未执行递归调用前返回。如果不这样做，在调用函数后，它永远不会返回。在递归函数中不使用if语句，
是一个很常见的错误。在开发过程中广泛使用printf()和 getchar()可以看到执行过程，并且可以在发现错误后停止运行。
                               

                               结构体


truct 结构名
{
　 成员表列
};

　　 成员表由若干个成员组成， 每个成员都是该结构的一个组成部分。对每个成员也必须作类型说明，其形式为：

　　 类型说明符 成员名;

　　 成员名的命名应符合标识符的书写规定。例如：

struct stu
{
　 int num;
　 char name[20];
　 char sex;
　 float score;
};

　　 在这个结构定义中，结构名为stu，该结构由4个成员组成。 第一个成员为num，整型变量；第二个成员为name，字符数组；
个成员为sex，字符变量；第四个成员为score，实型变量。 应注意在括号后的分号是不可少的。结构定义之后，即可进行变量说明。
凡说明为结构stu的变量都由上述4个成员组成。由此可见， 结构是一种复杂的数据类型，是数目固定，类型不同的若干有序变量的集合。

　　 结构类型变量的说明

　　 说明结构变量有以下三种方法。以上面定义的stu为例来加以说明。

　　 1. 先定义结构，再说明结构变量。如：

struct stu
{
　 int num;
　 char name[20];
　 char sex;
　 float score;
};
struct stu boy1,boy2;

　　 说明了两个变量boy1和boy2为stu结构类型。也可以用宏定义使一个符号常量来表示一个结构类型，例如：

#define STU struct stu
STU
{
　 int num;
　 char name[20];
　 char sex;
　 float score;
};
STU boy1,boy2;

　　 2. 在定义结构类型的同时说明结构变量。例如：

struct stu
{
　 int num;
　 char name[20];
　 char sex;
　 float score;
}boy1,boy2;

　　 3. 直接说明结构变量。例如：

struct
{
　 int num;
　 char name[20];
　 char sex;
　 float score;
}boy1,boy2;

　　 第三种方法与第二种方法的区别在于第三种方法中省去了结构名，而直接给出结构变量。说明了boy1,boy2变量为stu类型后，
即可向这两个变量中的各个成员赋值。在上述stu结构定义中，所有的成员都是基本数据类型或数组类型。成员也可以又是一个结构，
即构成了嵌套的结构。例如：

struct date{
　 int month;
　 int day;
　 int year;
}
struct{
　 int num;
　 char name[20];
　 char sex;
　 struct date birthday;
　 float score;
}boy1,boy2;

　　 首先定义一个结构date，由month(月)、day(日)、year(年) 三个成员组成。 在定义并说明变量 boy1 和 boy2 时，
其中的成员birthday被说明为data结构类型。成员名可与程序中其它变量同名，互不干扰。结构变量成员的表示方法
在程序中使用结构变量时， 往往不把它作为一个整体来使用。

　　 在ANSI C中除了允许具有相同类型的结构变量相互赋值以外， 一般对结构变量的使用，包括赋值、输入、输出、 运算等都是通过结构变量的成员来实现的。

　　 表示结构变量成员的一般形式是： 结构变量名.成员名 例如：boy1.num 即第一个人的学号　boy2.sex 即第二个人的性别 
如果成员本身又是一个结构则必须逐级找到最低级的成员才能使用。例如：boy1.birthday.month 即第一个人出生的月份成
员可以在程序中单独使用，与普通变量完全相同。 
